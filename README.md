# 동시성 제어에 대한 분석 및 보고

## 동시성 문제란?

동시성 문제란 여러 스레드가 동일한 자원에 동시에 접근하거나 작업할 때 발생하는 데이터 일관성 문제와 작업 순서의 예측 불가능성을 의미한다. 주로 멀티스레드 환경에서 발생하며, 올바르게 처리하지 않으면 프로그램이
비정상적으로 동작하거나 예기치 않은 결과를 초래할 수 있다.

## 동시성 제어란?

동시성 제어란 동시성 문제가 발생하지 않도록 여러 스레드가 공유 자원에 안전하게 접근하고 작업할 수 있게 하는 기법으로, 스레드 간 작업 순서와 자원 사용을 조율하여 데이터를 일관성 있고 예측 가능하게 유지하는 것을
의미한다.

## 환경 간 동시성 제어

- **분산 환경**  
  분산 환경에서의 동시성 제어는 여러 시스템이나 노드가 동일한 자원에 접근할 때 데이터의 일관성과 무결성을 보장하기 위해 사용한다. 여러 노드가 동시에 동일한 자원에 접근하면 데이터가 중복 처리될 수 있으므로 이를
  방지하기 위한 동시성 제어가 필요하다. 또한 단일 시스템과 달리 여러 노드가 동일 작업을 중복 실행하거나 잘못된 순서로 실행하지 않도록 제어해야 한다.

  **동시성 제어 방식**
  - *분산 락*  
    여러 노드가 동시에 동일한 자원에 접근하지 못하도록 제어하는 메커니즘이다.
    1. **DB를 활용한 분산 락**: 데이터베이스의 트랜잭션과 락 기능을 사용해 동시에 동일한 자원에 접근하지 못하도록 한다. 예를 들어 `FOR UPDATE` 등을 통한 비관적 락이나 버전 칼럼을 활용한
       낙관적 락 등을 적용할 수 있다.
    2. **Redis를 활용한 분산 락**: Redis의 빠른 속도와 간단한 Key-Value 저장소를 활용한 동시성 제어 방식을 제공한다. `SETNX`나 `SET`을 통해 락을 설정하고 `DEL` 등을 통해
       해제한다. 이 방식은 Redis 서버가 단일 장애 지점(SPOF)이 될 수 있지만, Redlock 알고리즘 등으로 극복이 가능하다.

- **단일 시스템**  
  단일 시스템에서의 동시성 제어는 하나의 프로세스 내 스레드가 공유 자원에 접근하는 상황에 초점을 맞춘다. 요구사항에서 정의한 환경은 단일 시스템 환경이므로, 아래에서는 단일 시스템에서의 동시성 제어 방식에 대해
  분석한다.

## 동시성 제어 방식 상세

### 1. Mutex(Mutual Exclusion)

임계 구역이 있는 스레드들이 실행 시간을 겹치지 않고 단독으로 실행되도록 하는 기법이다. 즉, 임계 구역에는 한 개의 스레드만 진입 가능하며, 이를 통해 데이터 무결성을 보호한다. 요구사항에서 “동시에 여러 요청이
들어오더라도 순서대로(혹은 한 번에 하나의 요청씩만) 제어될 수 있도록 리팩토링”하기 위해서는 상호 배제가 필수적이다.

1) **Synchronized**

- *개념*: 자바 키워드를 이용한 동기화 방식으로, 특정 블록이나 메서드에 하나의 스레드만 접근 가능하도록 한다.
- *특징*
  - 재진입 가능: 같은 스레드가 이미 획득한 모니터(락)를 연속해서 획득할 수 있다.
  - 공정성 보장 없음: 기다리는 스레드 순서대로 Lock을 주지 않으므로, 특정 스레드가 Lock 획득에 계속 실패할 수도 있다.
  - 구현이 간단하고 직관적이다.
- *장단점*
  - 장점: 사용이 쉽고, 간단한 임계 영역 보호에 충분하다.
  - 단점: 공정성 제어가 부족하고, 세밀한 Lock 획득과 해제 제어가 어렵다. 또한 Condition 기반 정교한 흐름 제어가 어렵다.

2) **ReentrantLock**

- *개념*: `java.util.concurrent.locks` 패키지가 제공하는 Lock 구현체로, 명시적으로 `lock()`과 `unlock()`을 호출해야 한다.
- *특징*
  - 재진입 가능하며, `tryLock()`이나 `lockInterruptibly()` 등 다양한 Lock 획득 전략을 제공한다.
  - `Condition` 객체를 통해 세밀한 대기와 알림을 제어할 수 있다.
  - 생성자에서 공정성 옵션을 설정하면, 스레드가 공평하게 Lock을 획득할 수 있다.
  - 결국 하나의 Lock 객체당 한 번에 한 스레드만 임계 구역에 진입할 수 있는 상호 배제(Mutex) 메커니즘을 제공한다.
- *장단점*
  - 장점: 세밀한 Lock 정책 설정이 가능하고, 공정성 제어와 조건변수 활용이 가능하다.
  - 단점: 명시적인 Lock 관리를 위해 `try-finally` 블록이 필요하며, 구현 난이도가 높다.

### 2. Semaphore

지정된 수의 스레드가 동시에 특정 자원에 접근할 수 있도록 하는 기법이다. 여러 스레드가 한 번에 임계 구역에 진입할 수 있으므로, 뮤텍스와는 달리 한 개 스레드가 진입을 책임지는 방식이 아니다.

- *개념*: N개의 허용량(permit)을 두어, 최대 N개의 스레드가 동시에 임계 구역에 진입할 수 있도록 하는 동시성 제어 기법이다.
- *특징*
  - `Synchronized`나 `ReentrantLock`이 기본적으로 “한 번에 한 스레드”만 허용하는 것과 달리, `Semaphore`는 “한 번에 여러 스레드”를 허용한다.
  - 리소스가 제한된 상황(예: 스레드 풀, 연결 풀)에서 주로 사용한다.
  - 뮤텍스는 세마포어가 될 수 없지만, 세마포어는 허용량이 1일 때 뮤텍스로 활용할 수 있다.
- *장단점*
  - 장점: 동시 접근 가능한 스레드 수를 유연하게 제어할 수 있다.
  - 단점: permit 관리를 직접 해주어야 하며, 단순 상호 배제보다 추가적인 접근 동시성 조절 로직이 필요하다.

## 어떻게 요구사항을 구현했는가?

나는 `ReentrantLock`을 사용해 요구사항을 구현했다.

- 앞서 언급했듯이, “동시에 여러 요청이 들어와도 순서대로(혹은 한 번에 하나씩) 제어”하기 위해서는 **Mutex**를 사용하는 것이 필수적이라 생각했다.
- 공정하게 Lock을 획득하려면 `Synchronized`보다는 `ReentrantLock`의 공정성 옵션을 활용하는 편이 스레드 간 순서를 보장하기 쉽다고 판단했다.
- 세마포어를 허용량 1로 설정해 뮤텍스로 사용하는 방법도 있지만, `ReentrantLock`이 해당 요구사항을 더 자연스럽게 충족하는 것으로 보인다.
- 실제로 `Semaphore` 허용량을 1로 두어 테스트해본 결과, 기능 자체는 동일하게 동작함을 확인했다.

### 알게 된 점

- `ReentrantLock`에서 공정 모드를 사용하지 않아도, 실험 결과 어느 정도는 스레드를 공정하게 분배해준다는 사실을 알게 되었다.
