# 애플리케이션 레벨 동시성 제어와 DB 레벨 Lock 비교

## 서론

애플리케이션은 다중 스레드 환경에서 동일한 자원에 대한 동시 접근으로 인한 문제를 해결하기 위해 동시성 제어 기법을 활용합니다. 이 글에서는 자바 애플리케이션 레벨에서 자주 사용하는 `Synchronized`,
`ReentrantLock`, `Semaphore`와 데이터베이스(DB) 레벨 Lock을 비교하고, 각각의 특징과 활용 시 주의사항을 살펴보겠습니다.

## 애플리케이션 레벨 동시성 제어 기법

### Synchronized

- **개념**: 자바 언어 키워드를 이용한 동기화 방식으로, 특정 블록 또는 메서드를 하나의 스레드만 접근 가능하도록 합니다.
- **특징**:
    - 재진입 가능(Reentrant): 같은 스레드가 이미 획득한 모니터(락)를 연속해서 획득할 수 있습니다.
    - 공정성(Fairness) 보장 없음: 기다리는 스레드 순서대로 Lock을 주지 않으며, 특정 스레드가 Lock 획득에 계속 실패하는 기아(Starvation)가 발생할 수 있습니다.
    - 구현이 간단하고 직관적이며, JVM 차원에서 관리됩니다.
- **장단점**:
    - 장점: 사용이 쉽고, 간단한 임계영역 보호에 충분
    - 단점: 공정성 제어 부족, 세밀한 Lock 획득/해제 제어 불가, Condition 기반의 정교한 흐름 제어 어려움

### ReentrantLock

- **개념**: `java.util.concurrent.locks` 패키지 제공 Lock 구현체로, 명시적으로 `lock()`/`unlock()` 호출이 필요합니다.
- **특징**:
    - 재진입 가능, `tryLock()`, `lockInterruptibly()` 등 다양한 Lock 획득 전략 제공
    - `Condition` 객체를 통한 세밀한 대기 및 알림 제어 가능
    - 공정성 옵션(Fairness)을 생성자에서 설정할 수 있어, 스레드가 공평하게 Lock을 획득할 수 있도록 설정할 수도 있습니다.
    - 결국 하나의 Lock 객체당 한 번에 한 스레드만 임계영역에 진입할 수 있는 상호배제(Mutex) 메커니즘을 제공합니다.
- **장단점**:
    - 장점: 세밀한 Lock 정책 설정 가능, 공정성 제어 가능, 조건변수 활용 가능
    - 단점: 명시적 Lock 관리 필요(try-finally), 구현 난이도 증가

### Semaphore

- **개념**: N개의 허용량(permit)을 주어, 최대 N개의 스레드가 동시에 임계영역에 진입할 수 있도록 하는 동시성 제어 기법입니다.
- **특징**:
    - `Synchronized`나 `ReentrantLock`이 기본적으로 "한 번에 한 스레드"만 허용하는데 비해, `Semaphore`는 "한 번에 여러 스레드"를 허용할 수 있습니다.
    - 리소스 개수가 제한된 상황(예: 스레드풀, 연결 풀)에서 사용하면 효율적입니다.
- **장단점**:
    - 장점: 동시 접근 가능한 스레드 수를 유연하게 제어
    - 단점: permit 관리 필요, 단순한 상호배제와 달리 접근 동시성을 조절하는 추가 로직이 필요

## 데이터베이스(DB) 레벨 Lock

- **개념**: DB 내부적으로 트랜잭션 단위로 Lock을 관리하며, 레코드나 테이블, 페이지 단위로 Lock을 할당해 동시성 제어를 수행합니다.
- **특징**:
    - Isolation Level과 연계되어, 일관성(Consistency)과 무결성(Integrity)을 보장
    - 낙관적/비관적 Locking 전략, Deadlock 회피/감지 기법 등 다양한 Lock 관리 전략 제공
- **장단점**:
    - 장점: 실제 데이터 일관성 보장, 분산 환경에서도 적용 가능
    - 단점: Lock 경합 시 DB 성능 저하, Deadlock 발생 가능, 애플리케이션 레벨에서 제어하기 어려움

## 비교 표

| 구분            | 적용 레벨      | 획득/해제 제어          | 특징                              | 조건 제어 가능성          | 동시 허용 수준        | 공정성 옵션    | 사용 난이도 | 대표적 사용 케이스           |
|---------------|------------|-------------------|---------------------------------|--------------------|-----------------|-----------|--------|----------------------|
| Synchronized  | JVM(언어 차원) | 자동(블록/메서드 단위)     | 단순 상호배제, 재진입 가능, 공정성 불보장        | 제한적(`wait/notify`) | 1 스레드           | 없음        | 쉬움     | 단순한 임계영역 보호          |
| ReentrantLock | 자바 라이브러리   | 명시적(lock/unlock)  | 재진입 가능, 세밀한 Lock 획득 전략, 조건변수 사용 | `Condition` 객체로 가능 | 1 스레드           | 설정 가능     | 중간     | 고급 동기화 로직, 조건 대기/알림  |
| Semaphore     | 자바 라이브러리   | 명시적(permit 획득/반환) | 동시 허용량 제어 (N개 스레드 동시 진입 가능)     | 별도 구현 필요           | N 스레드(permit 수) | N/A       | 중간     | 리소스 풀, 연결 풀 관리       |
| DB Lock       | DB 엔진      | 트랜잭션 단위로 자동 관리    | DB 차원의 데이터 일관성 보장               | 낙관적/비관적 Locking 전략 | 다수 트랜잭션 관리 가능   | DB 정책에 따름 | 높음     | 실제 데이터 무결성 보장, 분산 환경 |

## 결론

- `Synchronized`와 `ReentrantLock`은 기본적으로 "한 번에 한 스레드"에 대한 임계영역 보호를 제공하지만, `ReentrantLock`은 공정성 옵션과 조건변수를 통해 더 세밀한 제어가
  가능합니다.
- `Semaphore`는 동시 접근 가능한 스레드 수를 유연하게 조절할 수 있어, 단순한 상호배제가 아닌 동시적 접근 제어 상황에 유용합니다.
- DB 레벨 Lock은 애플리케이션 레벨 Lock보다 무겁고 복잡하지만, 데이터 무결성과 일관성 보장에 필수적이며 대규모 분산 환경에도 대응 가능합니다.
- 상황에 따라 적절한 기법을 선택하며, 필요하다면 애플리케이션 레벨 Lock과 DB 레벨 Lock을 혼합 활용하여 성능과 안정성을 균형 있게 확보할 수 있습니다.
